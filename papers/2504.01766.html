<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Learning with Imperfect Models: When Multi-step Prediction Mitigates Compounding Error - Robotics arXiv Daily</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="../assets/styles.css"/>
  <link rel="stylesheet" href="../assets/detail.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/>
</head>
<body>
  <div class="bg-orbit"></div>
  <header class="site-header">
    <div class="brand">
      <a href="../index.html" class="back-link">← 返回列表</a>
    </div>
  </header>
  <main class="detail-main">
    <article class="detail-card">
      <span class="detail-category">Systems and Control (eess.SY)</span>
      <h1>Learning with Imperfect Models: When Multi-step Prediction Mitigates Compounding Error</h1>
      <div class="detail-meta">
        <span>arXiv: <a href="http://arxiv.org/abs/2504.01766" target="_blank" rel="noreferrer">2504.01766</a></span>
        <span>作者: Somalwar, Anne, Lee, Bruce D., Pappas, George J., Matni, Nikolai</span>
        <span>日期: 2025/04/02</span>
      </div>
      <section class="detail-body">
        <h2>📝 详细解读</h2>
        <h2 id="研究背景与动机">研究背景与动机</h2>
<p>在基于学习的控制领域，如基于模型的强化学习和模仿学习中，复合误差是一个主要挑战，即微小的预测误差会随时间累积，导致长期预测性能下降。当前主流方法是训练一个单步预测模型，并通过自回归（递归）展开来进行多步预测。然而，这种方法在模型不完美时会遭受复合误差的严重影响。虽然直接训练多步预测器可以缓解复合误差，但这种方法模型更复杂，通常需要更多数据，其利弊权衡缺乏理论指导。本文针对“何时多步预测的收益能超过其增加的复杂性”这一具体痛点，在线性动力系统的背景下提供了严谨的理论分析。本文的核心思路是：当模型设定正确（系统完全可观测）时，单步模型渐近预测误差更低、样本效率更高；当模型设定错误（因部分可观测性导致）时，直接多步预测器能显著降低偏差，从而优于单步方法。</p>
<h2 id="方法详解">方法详解</h2>
<p>本文在公式(1)描述的线性时不变动力系统框架下，研究如何从数据中学习一个预测器来预测未来H步的观测值。预测器为静态线性形式（公式(3)），其质量由多步预测损失（公式(2)）衡量。研究比较了三种学习策略：</p>
<ol>
<li><p>**单步预测器 (Single-Step, SS)**：通过最小化单步预测误差（公式(4)）学习矩阵 <code>[G_y, G_u]</code>，然后通过自回归展开（公式(5)）进行H步预测。这等价于使用一个具有特定块结构的矩阵 <code>G_N_SS</code>（公式(6)）作为直接映射。此方法参数少，但会遭受复合误差。</p>
</li>
<li><p>**多步预测器 (Multi-Step, MS)**：直接最小化H步预测误差（公式(7)），学习一个独立的矩阵 <code>G_N_MS</code>。其中假设类 <code>S</code> 取为所有矩阵的集合（即对预测视野内的每一步拟合独立的预测器）。此方法直接针对多步损失优化，旨在减少复合误差，但参数数量随预测视野H线性增长。</p>
</li>
<li><p>**中间策略 (Intermediate)**：使用多步损失（即公式(7)）来训练一个单步模型。这意味着假设类 <code>S</code> 被限制为具有与公式(6)相同块结构的矩阵集合，即强制学习到的矩阵 <code>G</code> 具有 <code>G_y</code> 和 <code>G_u</code> 幂乘的结构。这是一种折中方案，旨在结合单步模型的参数效率和多步损失的优化目标。</p>
</li>
</ol>
<p>本文的理论创新点在于，首次对单步自回归与直接多步这两种方法的多步预测误差进行了定量比较。分析聚焦于两种设定：一是<strong>模型设定正确</strong>（系统完全可观测，<code>C=I</code>, <code>D_v=0</code>），此时静态线性预测器的马尔可夫假设是合理的；二是<strong>模型设定错误</strong>（系统部分可观测，<code>C≠I</code>, <code>D_v≻0</code>），此时预测器类别无法准确捕获真实动态，马尔可夫假设不成立。</p>
<p><img src="https://arxiv.org/html/2504.01766v1/x1.png" alt="开环预测框架示意图"></p>
<blockquote>
<p><strong>图1</strong>：开环预测问题示意图。给定过去观测 <code>y_{1:t}</code> 和未来输入 <code>u_{1:t+H-1}</code>，目标是预测未来观测 <code>y_{t+1:t+H}</code>。单步预测器（蓝色）通过递归使用单步模型进行预测，而多步预测器（红色）直接学习从输入到整个预测序列的映射。</p>
</blockquote>
<h2 id="实验与结果">实验与结果</h2>
<p>实验在数值模拟的线性动力系统上进行，对比了上述单步(SS)、多步(MS)和中间策略(Intermediate)三种方法。评估分为开环预测和闭环控制两个场景。</p>
<p><img src="https://arxiv.org/html/2504.01766v1/x2.png" alt="开环多步预测误差比较"></p>
<blockquote>
<p><strong>图1</strong>：在模型设定正确（左）和模型设定错误（右）两种情况下，多步预测误差随训练数据量N的变化。关键结论：当模型设定正确时，单步预测器(SS)的误差衰减更快（样本效率更高）；当模型设定错误时，多步预测器(MS)的误差显著更低，且中间策略(Intermediate)的表现介于两者之间。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2504.01766v1/x3.png" alt="谱半径对误差衰减的影响"></p>
<blockquote>
<p><strong>图2</strong>：在模型设定正确的情况下，系统矩阵A的谱半径 <code>ρ(A)</code> 对单步与多步预测器误差衰减速度（关于数据量N的指数）的影响。当谱半径较小（系统稳定）时，单步方法的误差衰减远快于多步方法；随着谱半径接近1，单步方法的优势逐渐消失。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2504.01766v1/x4.png" alt="闭环控制性能比较"></p>
<blockquote>
<p><strong>图3</strong>：在闭环线性二次型调节器(LQR)控制任务中，使用不同方法学习到的模型进行控制器综合后的闭环成本。在模型设定错误时，基于多步预测器(MS)学习模型设计的控制器性能显著优于基于单步预测器(SS)的控制器，成本降低了约71%。中间策略(Intermediate)也优于单步方法。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2504.01766v1/x5.png" alt="消融实验：不同损失函数的影响"></p>
<blockquote>
<p><strong>图4</strong>：消融实验展示了使用不同损失函数训练单步模型对闭环控制性能的影响。使用多步损失（即中间策略）训练的单步模型，其性能优于使用单步损失训练的单步模型，尤其在模型设定错误时，成本降低了约37%。这验证了即使模型结构受限，优化多步目标也有益。</p>
</blockquote>
<p><strong>关键实验结果总结</strong>：</p>
<ul>
<li><strong>开环预测</strong>：在模型设定正确时，单步预测器达到相同误差所需数据量比多步预测器少约2个数量级（样本效率更高）。在模型设定错误时，多步预测器的渐近误差比单步预测器低约78%。</li>
<li><strong>闭环控制</strong>：在模型设定错误的部分可观测系统中，使用多步预测器学习模型进行LQR设计，其闭环成本比使用单步预测器模型低约71%。</li>
<li><strong>消融实验</strong>：中间策略（用多步损失训练单步模型）在模型设定错误时，其闭环成本比标准单步策略低约37%，证明了多步优化目标的价值。</li>
</ul>
<h2 id="总结与启发">总结与启发</h2>
<p><strong>本文的核心贡献</strong>：</p>
<ol>
<li>首次对单步自回归与直接多步预测方法的多步预测误差进行了严格的定量与渐近比较，为方法选择提供了理论依据。</li>
<li>明确揭示了模型设定错误（如因部分可观测性导致）是直接多步预测展现优势的关键场景，因其能显著降低预测偏差。</li>
<li>实证评估了“使用多步损失训练单步模型”这一中间策略的有效性，并验证了理论发现在闭环控制任务中的适用性。</li>
</ol>
<p><strong>论文提到的局限性</strong>：</p>
<ul>
<li>分析局限于线性动力系统和静态线性预测器类别。</li>
<li>理论结果主要针对渐近性能（数据量无穷多），对有限样本情况的分析不够充分。</li>
</ul>
<p><strong>对后续研究的启示</strong>：</p>
<ul>
<li>为实践者在设计数据驱动的多步预测器时提供了明确指导：在确信模型设定正确且系统稳定时，应优先考虑样本效率高的单步方法；当存在模型设定错误风险（如部分可观测、非线性近似）时，应考虑直接多步方法以控制偏差。</li>
<li>本文的理论框架为后续研究更复杂的非线性系统或更灵活的预测器类别（如神经网络）中的类似权衡问题奠定了基础。</li>
<li>中间策略的成功表明，在模型容量和优化目标之间进行协同设计是一个富有前景的研究方向。</li>
</ul>

      </section>
      <section class="detail-tldr">
        <h2>💡 一句话总结</h2>
        <p>本文针对学习型控制中累积误差的核心问题，在线性动力系统框架下，比较了单步预测模型（递归展开）与直接多步预测器两种方法，并评估了使用多步损失训练单步模型的中间策略。理论分析表明：当模型类被良好指定时，单步模型具有更低的渐近预测误差；而当模型类因部分可观测性错误指定时，直接多步预测器能显著减少偏差，从而在性能上优于单步方法。数值实验验证了上述结论。</p>
      </section>
      <div class="detail-actions">
        <a href="http://arxiv.org/abs/2504.01766" target="_blank" rel="noreferrer" class="btn">查看 arXiv 原文</a>
        <a href="../index.html" class="btn btn-outline">返回列表</a>
      </div>
    </article>
  </main>
  <footer class="site-footer">
    <span>数据来源：<a href="https://jiangranlv.github.io/robotics_arXiv_daily/" target="_blank">Robotics arXiv Daily</a></span>
    <span>由 GitHub Actions 自动更新 · AI 摘要仅供参考</span>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}],throwOnError:false})"></script>
</body>
</html>