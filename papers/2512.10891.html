<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Iterative Compositional Data Generation for Robot Control - Robotics arXiv Daily</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="../assets/styles.css"/>
  <link rel="stylesheet" href="../assets/detail.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/>
</head>
<body>
  <div class="bg-orbit"></div>
  <header class="site-header">
    <div class="brand">
      <a href="../index.html" class="back-link">← 返回列表</a>
    </div>
  </header>
  <main class="detail-main">
    <article class="detail-card">
      <span class="detail-category">Manipulation</span>
      <h1>Iterative Compositional Data Generation for Robot Control</h1>
      <div class="detail-meta">
        <span>arXiv: <a href="http://arxiv.org/abs/2512.10891" target="_blank" rel="noreferrer">2512.10891</a></span>
        <span>作者: Eric Eaton Team</span>
        <span>日期: 2025-12-12</span>
      </div>
      <section class="detail-body">
        <h2>📝 详细解读</h2>
        <h2 id="研究背景与动机">研究背景与动机</h2>
<p>在机器人操作领域，收集真实数据成本高昂，使得为多物体、多机器人、多环境场景中组合爆炸的任务空间获取演示变得不切实际。虽然最近的生成模型可以为单个任务合成有用数据，但它们未能利用机器人领域的组合结构，难以泛化到未见过的任务组合。现有方法多专注于提升单任务内的样本效率，而未能利用自生成数据来加速学习全新任务。本文针对组合泛化这一具体痛点，提出了一种新视角：通过构建显式利用组合性的模型架构，实现为零样本、未见过的任务组合生成高质量的合成训练数据。核心思路是设计一个语义组合扩散变换器，将状态转移分解为机器人、物体、障碍物和目标等特定组件，并通过注意力学习它们的交互，进而通过迭代自改进程序，利用合成数据不断提升模型解决新任务的能力。</p>
<h2 id="方法详解">方法详解</h2>
<p>本文提出的方法是一个迭代的组合数据生成流程，核心是一个语义组合扩散变换器（Semantic Compositional Diffusion Transformer）。</p>
<p><img src="https://arxiv.org/html/2512.10891v3/x4.png" alt="方法框架"></p>
<blockquote>
<p><strong>图4</strong>：语义组合变换器架构。将每个转移（transition）分解为状态因子（如不同机器人）、动作、奖励和终止指示器。每个状态因子有自己独立的编码器-解码器对。编码后的令牌与位置嵌入一起，由多个扩散变换器层处理，这些层受时间步和任务指示器嵌入的条件自适应归一化调制。输出令牌由因子特定的解码器解码。当前状态和下一状态的编码器-解码器对是共享的。</p>
</blockquote>
<p>整体框架如算法1所述：首先在部分任务（14个）的真实数据上训练初始扩散模型。然后，在每一轮迭代中，使用当前模型为零样本的未见任务生成合成数据，并用离线强化学习算法（TD3-BC）基于这些合成数据训练策略，随后在环境中在线评估该策略的成功率。若某个任务的合成数据能训练出成功率超过阈值τ的策略，则将该合成数据加入下一轮的训练集，用于重新训练扩散模型。此过程迭代进行，旨在逐步扩展模型能有效生成数据的任务范围。</p>
<p>核心模块是语义组合扩散变换器。它基于扩散变换器（DiT）构建，但关键创新在于其<strong>因子特定（factor-specific）的令牌化方案</strong>。具体而言，它将一个转移元组 <code>&lt;s, a, r, s&#39;, d&gt;</code> 的每个组成部分（对应组合任务图中的一个基本元素 <code>f ∈ F</code>，如特定机器人、物体、障碍物、目标、动作、奖励、终止信号）通过一个独立的编码器-解码器对 <code>(e_f, o_f)</code> 进行映射。编码器将原始输入映射到学习到的嵌入空间，形成一组令牌 <code>(y^f)</code>。这些令牌随后被送入共享的扩散变换器层进行处理。</p>
<p>扩散变换器层通过自注意力机制，让每个因子令牌可以关注所有其他因子令牌，从而<strong>学习因子之间的交互关系</strong>，这相当于从数据中推断出任务组合的计算图结构，而非像先前工作那样硬编码。条件信息（扩散时间步t和任务索引n）通过一个额外的嵌入路径注入，该路径生成自适应层归一化的参数，以调制每个变换器块，从而在不干扰已学习的组合语义的前提下实现任务条件生成。</p>
<p>与现有方法相比，创新点具体体现在：1) <strong>组合式令牌化</strong>：为每个任务组件（因子）使用独立的编码器，而非共享编码器或简单分块，使模型能学习组件特定的表示空间。2) <strong>从数据中学习图结构</strong>：利用变换器作为图神经网络（GNN）的解释，通过注意力权重自动发现组合任务中组件间的依赖关系。3) <strong>迭代自改进与抗崩溃机制</strong>：通过算法1迭代地利用高质量合成数据改进生成模型。由于合成数据仅用于更新其对应任务所涉及的那些因子特定编码器的参数，这种参数的部分隔离有助于缓解生成模型迭代训练中常见的“模型崩溃”问题。</p>
<h2 id="实验与结果">实验与结果</h2>
<p>实验在模拟机器人操作基准测试 <strong>CompoSuite</strong> 的一个子集上进行，该子集包含64个任务（固定使用IIWA机器人，组合4种物体×4种障碍×4种目标）。初始训练集仅包含其中14个任务的专家数据，目标是解决其余50个未见任务中的32个测试任务。</p>
<p>对比的基线方法包括：</p>
<ul>
<li><strong>静态离线RL方法</strong>：硬编码组合RL、语义组合RL。</li>
<li><strong>迭代数据生成基线</strong>：整体式架构（Monolithic，基于SynthER）、标准DiT（无组合令牌化）、语义DiT（共享编码器，即按语义分块但同一轴内组件共享参数）。</li>
</ul>
<p><img src="https://arxiv.org/html/2512.10891v3/x5.png" alt="零样本性能对比"></p>
<blockquote>
<p><strong>图5</strong>：不同模型架构在初始训练后的零样本生成性能（通过训练出的策略成功率衡量）。本文的语义组合扩散变换器（Factor-Specific）显著优于整体式、标准DiT和共享编码器的语义DiT基线，证明了因子特定编码器对学习组合结构的重要性。</p>
</blockquote>
<p>关键结果显示，在仅使用初始14个任务数据训练后，本文方法的零样本生成性能（成功率约45%）远超最佳基线（语义DiT，约5%）。经过<strong>迭代自改进</strong>后，性能得到大幅提升。</p>
<p><img src="https://arxiv.org/html/2512.10891v3/x6.png" alt="迭代改进性能"></p>
<blockquote>
<p><strong>图6</strong>：迭代自改进过程中，在测试任务上的平均成功率。本文方法（Factor-Specific）经过约10轮迭代后，成功率接近100%，而所有基线方法均无法通过迭代获得显著提升。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2512.10891v3/x7.png" alt="任务解决进度"></p>
<blockquote>
<p><strong>图7</strong>：随着迭代轮次增加，被解决（成功率&gt;阈值）的测试任务数量。本文方法能逐步解决几乎所有测试任务。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2512.10891v3/x8.png" alt="消融实验：编码器类型"></p>
<blockquote>
<p><strong>图8</strong>：消融实验验证了各组件贡献。因子特定编码器（Factor-Specific）是高性能的关键；迭代过程（Iterative）带来了巨大增益；而条件生成（Conditional）也是必要的。共享编码器（Shared）性能很差。</p>
</blockquote>
<p>消融实验总结：1) <strong>因子特定编码器</strong>是获得强大零样本泛化能力的核心。2) <strong>迭代自改进程序</strong>能将性能从约45%提升至近100%。3) <strong>条件生成</strong>（将任务标识作为输入）是有效的，移除后性能下降。</p>
<h2 id="总结与启发">总结与启发</h2>
<p>本文的核心贡献在于：1) 提出了<strong>语义组合扩散变换器</strong>，通过因子特定的令牌化方案和变换器注意力机制，从数据中自动学习组合任务的结构，实现了高质量的零样本数据生成。2) 设计了一种<strong>迭代自改进程序</strong>，通过离线RL验证合成数据质量，并选择性地将其加入训练集，使生成模型能不断扩展其解决新任务组合的能力，最终解决了几乎所有未见任务。3) 分析表明，模型学习到的分解结构与先前硬编码的方法不同，表明<strong>有效的组合结构可以从数据中自动涌现</strong>。</p>
<p>论文自身提到的局限性包括：迭代过程中需要在线评估策略，这在真实机器人上成本高昂；实验限于中等规模的任务组合（64个任务），更大规模组合的扩展性有待验证；方法依赖于任务组合的因子可分解性假设。</p>
<p>对后续研究的启示包括：证明了为组合性设计模型架构（尤其是学习组件特定表示）对泛化至关重要；迭代利用自生成数据是突破有限初始数据瓶颈的有效途径，其关键在于设计抗模型崩溃的机制（如参数隔离）；将变换器视为GNN并用于学习组合关系，为构建可解释、可组合的机器人学习系统提供了新思路。</p>

      </section>
      <section class="detail-tldr">
        <h2>💡 一句话总结</h2>
        <p>论文针对机器人操控数据收集昂贵、组合任务泛化困难的问题，提出语义组合扩散变换器，将状态过渡分解为机器人、对象、障碍物和目标特定组件，通过注意力机制学习交互；并引入迭代自我改进程序，利用离线强化学习验证合成数据并迭代训练。实验表明，该方法在有限任务训练后能零样本生成高质量过渡数据，从中学习未见任务组合的控制策略，性能显著优于整体和硬编码组合基线，最终解决几乎所有保留任务，学习表示中涌现出有意义组合结构。</p>
      </section>
      <div class="detail-actions">
        <a href="http://arxiv.org/abs/2512.10891" target="_blank" rel="noreferrer" class="btn">查看 arXiv 原文</a>
        <a href="../index.html" class="btn btn-outline">返回列表</a>
      </div>
    </article>
  </main>
  <footer class="site-footer">
    <span>数据抓取来源于 Robotics arXiv Daily</span>
    <span>本页由 GitHub Actions 定时更新</span>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}],throwOnError:false})"></script>
</body>
</html>