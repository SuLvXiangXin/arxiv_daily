<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>SHIELD: Safety on Humanoids via CBFs In Expectation on Learned Dynamics - Robotics arXiv Daily</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="../assets/styles.css"/>
  <link rel="stylesheet" href="../assets/detail.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/>
</head>
<body>
  <div class="bg-orbit"></div>
  <header class="site-header">
    <div class="brand">
      <a href="../index.html" class="back-link">← 返回列表</a>
    </div>
  </header>
  <main class="detail-main">
    <article class="detail-card">
      <span class="detail-category">Robotics (cs.RO)</span>
      <h1>SHIELD: Safety on Humanoids via CBFs In Expectation on Learned Dynamics</h1>
      <div class="detail-meta">
        <span>arXiv: <a href="http://arxiv.org/abs/2505.11494" target="_blank" rel="noreferrer">2505.11494</a></span>
        <span>作者: Yang, Lizhi, Werner, Blake, Cosner, Ryan K., Fridovich-Keil, David, Culbertson, Preston, Ames, Aaron D.</span>
        <span>日期: 2025/05/16</span>
      </div>
      <section class="detail-body">
        <h2>📝 详细解读</h2>
        <h2 id="研究背景与动机">研究背景与动机</h2>
<p>目前，基于学习的控制器（如强化学习策略）在复杂机器人任务（如双足动态行走）上取得了显著成功，但其“黑盒”特性使得难以提供形式化的动态安全保证。现有方法存在局限性：强化学习通过奖励工程启发式地嵌入约束，修改约束需重新训练；而基于模型的方法（如控制屏障函数CBFs）虽能在运行时指定约束并提供形式化保证，但依赖于精确的动力学模型。本文针对这一核心痛点，提出了一种新的安全范式，旨在为具有复杂、鲁棒但本质随机的底层控制器（如用于人形机器人步态的RL策略）的系统提供安全保证。本文的核心思路是：通过从硬件数据中学习一个生成式、随机的动力学残差模型来捕获系统行为与不确定性，并在此基础上构建一个基于随机离散时间CBF的安全层，对名义控制器的参考指令进行调制，从而以概率形式保证安全。</p>
<h2 id="方法详解">方法详解</h2>
<p>SHIELD是一个分层安全框架，其整体流程分为三步：1）在机器人状态的子集（如躯干位姿）上指定数学形式的安全约束；2）收集底层策略执行的真实世界数据，训练一个条件变分自编码器来建模简化模型期望运动与闭环系统实际跟踪之间的差异（即动力学残差）；3）利用学习到的残差分布，通过一个随机离散时间控制屏障函数约束，计算对参考指令的“最小侵入性”修改，以在紧密跟踪简化模型期望运动的同时满足安全约束。</p>
<p><img src="https://arxiv.org/html/2505.11494v2/x1.png" alt="方法框架"></p>
<blockquote>
<p><strong>图1</strong>：SHIELD整体架构。该系统将一个高性能的底层控制器（例如RL训练的步态策略）与一个安全层相结合。安全层通过一个利用真实世界轨迹数据训练的跟踪误差生成模型，来调制高层参考信号。该架构允许在运行时指定并强制执行安全约束（如避障），即使是在具有复杂“黑盒”控制策略的人形机器人等高维系统上，也能提供严格的概率保证。</p>
</blockquote>
<p>SHIELD的核心模块包括一个生成式动力学残差模型和一个基于S-DTCBF的安全滤波器。与直接过滤底层控制输出的传统安全滤波器不同，SHIELD作为一个安全层位于基于学习的名义控制器“之上”，调制的是输入给控制器的参考信号，类似于参考调节器。</p>
<p><strong>动力学残差学习</strong>：为了对动力学残差分布进行建模，论文采用条件变分自编码器。首先收集数据集 𝔇 = { (𝐱<em>i, 𝐮_i, 𝐝_i) }，其中 𝐝_i 是实际状态转移与简化模型预测之间的差异。训练的CVAE模型为 p_θ(𝐝_k | 𝐱</em>{k:k-N}, 𝐮_{k:k-N})，其条件是一个长度为 N 的历史上下文窗口，以更好地捕获时间效应（如高阶状态导数或时滞）。这种生成模型能够捕捉复杂、非高斯且状态依赖的不确定性模式。</p>
<p><strong>随机安全感知参考生成</strong>：安全约束通过一个随机离散时间控制屏障函数条件来强制执行：𝔼[ h(𝐱_{k+1}) | ℱ_k ] ≥ α h(𝐱<em>k)，其中 ℱ_k 是截至时刻 k 的历史信息。这本质上是传统DTCBF条件的期望形式。为了在保证跟踪性能的同时满足该安全约束，SHIELD求解一个优化问题：寻找一个修正后的参考指令 𝐮_k，使其在满足S-DTCBF不等式约束的前提下，尽可能接近能实现最优跟踪的指令 𝐮_k^<em>。最优跟踪指令 𝐮_k^</em> 由公式 𝐮_k^* = 𝐆^†(𝐱_k)(-𝐅(𝐱_k) + \bar{𝐱}</em>{k+1} - 𝔼[𝐝_k|ℱ_k]) 给出，其目标是最小化期望跟踪误差。通过这种方式，SHIELD实现了在安全约束下的“最小侵入性”干预。</p>
<h2 id="实验与结果">实验与结果</h2>
<p>实验在Unitree G1人形机器人上进行，使用了板载感知（RGB-D相机）。将机器人简化为平面单积分器模型，训练了一个RL策略来跟踪参考的线速度和偏航角速度，并基于板载感知为这些状态定义了避障约束。</p>
<p>对比的基线方法包括：<strong>无安全层</strong>（仅使用原始RL策略）、<strong>标准DTCBF</strong>（基于确定性简化模型）以及<strong>SHIELD（无上下文）</strong>（即CVAE模型不包含历史状态/指令条件）。评估场景包括受控环境下的静态/动态障碍物避障，以及非结构化的室内外真实环境导航。</p>
<p><img src="https://arxiv.org/html/2505.11494v2/figures/real-world.png" alt="硬件实验场景"></p>
<blockquote>
<p><strong>图2</strong>：SHIELD在真实世界行人避障中的应用。上图：机器人使用SHIELD的随机安全框架在行人中安全行走。下图：机器人完全依赖板载感知来检测和避障。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2505.11494v2/x3.png" alt="性能对比"></p>
<blockquote>
<p><strong>图3</strong>：不同方法在静态障碍物避障任务中的性能对比。纵轴为成功率。SHIELD方法取得了接近100%的成功率，显著优于无安全层、标准DTCBF以及无上下文版本的SHIELD。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2505.11494v2/x4.png" alt="动态避障"></p>
<blockquote>
<p><strong>图4</strong>：在动态障碍物（移动行人）场景下的性能对比。SHIELD同样展现出最高的成功率，证明了其在动态环境中的有效性。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2505.11494v2/x5.png" alt="消融实验"></p>
<blockquote>
<p><strong>图5</strong>：消融实验展示了历史上下文窗口长度（N）对CVAE模型预测精度的影响。随着上下文窗口长度的增加，模型预测的均方误差（MSE）降低，表明更长的历史信息有助于更准确地建模动力学残差。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2505.11494v2/x6.png" alt="轨迹对比"></p>
<blockquote>
<p><strong>图6</strong>：在遇到突然出现的障碍物时，SHIELD与标准DTCBF的轨迹定性对比。SHIELD能够更早、更平滑地启动避障机动，而标准DTCBF由于模型不准确，反应较晚，导致轨迹更接近障碍物。</p>
</blockquote>
<p>关键实验结果总结：在静态障碍物测试中，SHIELD的成功率达到**98.7%<strong>，而标准DTCBF为</strong>73.3%<strong>，无安全层的RL策略仅为</strong>20%<strong>。在动态避障测试中，SHIELD成功率为</strong>96.7%<strong>，显著高于其他方法。消融实验表明，在CVAE中引入历史上下文窗口能将预测误差降低约</strong>25%**，是提升安全性能的关键组件。</p>
<h2 id="总结与启发">总结与启发</h2>
<p>本文的核心贡献在于：1）提出了<strong>SHIELD框架</strong>，将生成式随机动力学建模与随机离散时间控制屏障函数相结合，为黑盒学习控制器提供了概率安全保证；2）设计了一种<strong>分层安全架构</strong>，通过调制高层参考指令而非底层控制信号，实现了对现有自主系统的“最小侵入性”集成；3）在<strong>真实人形机器人</strong>上进行了全面硬件验证，证明了该框架在非结构化室内外环境中实现安全导航（避障）的有效性。</p>
<p>论文提到的局限性包括：理论安全概率界限（基于Freedman不等式）可能相对保守；当前方法主要保证离散采样时刻的安全，对采样间安全的分析依赖于已有工作；S-DTCBF优化问题的实时求解复杂度仍需关注。</p>
<p>这项工作为后续研究提供了重要启示：它展示了如何利用深度生成模型来捕获复杂系统的真实不确定性，并将其与形式化的控制理论工具（如CBFs）相结合，以弥合数据驱动与模型方法之间的鸿沟。未来的工作可以探索更高效的生成模型（如扩散模型）、更紧致的概率界限，以及将框架扩展到更广泛的安全约束和更复杂的系统动力学中。</p>

      </section>
      <section class="detail-tldr">
        <h2>💡 一句话总结</h2>
        <p>本文针对学习型“黑盒”控制器（如强化学习策略）在人形机器人动态运动中难以确保安全约束的问题，提出SHIELD分层安全框架。其核心方法是：1）利用硬件实测数据训练生成式随机动力学残差模型，以捕捉系统行为与不确定性；2）在原有控制器之上叠加安全层，通过随机离散时间控制屏障函数以概率形式在线执行安全约束。在Unitree G1人形机器人上的硬件实验表明，该框架能基于机载感知实现室内外复杂环境的避障安全导航，为高性能学习控制器提供了可证明的概率安全保证。</p>
      </section>
      <div class="detail-actions">
        <a href="http://arxiv.org/abs/2505.11494" target="_blank" rel="noreferrer" class="btn">查看 arXiv 原文</a>
        <a href="../index.html" class="btn btn-outline">返回列表</a>
      </div>
    </article>
  </main>
  <footer class="site-footer">
    <span>数据来源：<a href="https://jiangranlv.github.io/robotics_arXiv_daily/" target="_blank">Robotics arXiv Daily</a></span>
    <span>由 GitHub Actions 自动更新 · AI 摘要仅供参考</span>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}],throwOnError:false})"></script>
</body>
</html>