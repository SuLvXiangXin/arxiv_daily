<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Reshaping Action Error Distributions for Reliable Vision-Language-Action Models - Robotics arXiv Daily</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="../assets/styles.css"/>
  <link rel="stylesheet" href="../assets/detail.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/>
</head>
<body>
  <div class="bg-orbit"></div>
  <header class="site-header">
    <div class="brand">
      <a href="../index.html" class="back-link">← 返回列表</a>
    </div>
  </header>
  <main class="detail-main">
    <article class="detail-card">
      <span class="detail-category">Manipulation</span>
      <h1>Reshaping Action Error Distributions for Reliable Vision-Language-Action Models</h1>
      <div class="detail-meta">
        <span>arXiv: <a href="http://arxiv.org/abs/2602.04228" target="_blank" rel="noreferrer">2602.04228</a></span>
        <span>作者: Badong Chen Team</span>
        <span>日期: 2026-02-04</span>
      </div>
      <section class="detail-body">
        <h2>📝 详细解读</h2>
        <h2 id="研究背景与动机">研究背景与动机</h2>
<p>在机器人操作领域，视觉-语言-动作（VLA）模型已成为学习泛化性强、可扩展策略的有前景范式。现有VLA框架大多依赖标准监督目标，即对离散动作使用交叉熵，对连续动作回归使用均方误差（MSE）。这些目标对单个预测施加了强点对点约束。本文聚焦于连续动作VLA模型，旨在超越传统的基于MSE的回归方法，通过在训练过程中重塑动作误差分布来提升性能。</p>
<p>尽管MSE在实践中取得了经验成功并具有稳定的优化特性，但它仅在单个动作预测层面运作。从分析角度看，动作预测误差不仅可以被视为孤立的偏差，也可以被视为从随时间推移和动作维度演化的底层误差分布中抽取的样本。这种分布通常表现出结构化模式（如离散度、偏度或相关变化），即使每步回归损失已优化得很好。这表明，除了每步精度，动作误差的整体组织和几何结构并未受到点对点回归目标的显式调控。从分布视角看，策略的行为不仅受单个误差大小的影响，也受整个误差分布的不确定性、集中度和结构的影响。</p>
<p>信息论准则为刻画此类分布级属性提供了自然框架，因为它们直接作用于概率分布而非单个样本。其中，基于熵的目标提供了一种原则性方法来量化误差分布的集中或离散程度，而无需依赖强参数假设。最小误差熵（MEE）准则直接针对动作误差分布的熵，使得批次内或轨迹内的误差能够相互作用，提供了一种超越点对点回归的误差聚合机制。</p>
<p>本文核心思路是：将信息论中的最小误差熵（MEE）准则引入连续动作VLA模型的训练中，提出轨迹级MEE及其加权变体，与MSE结合，以重塑动作误差分布，从而提升策略的成功率和鲁棒性。</p>
<h2 id="方法详解">方法详解</h2>
<p>本文方法的核心是在标准MSE损失的基础上，引入基于最小误差熵（MEE）的轨迹级监督目标，以共同优化动作预测。</p>
<p>整体训练目标结合了标准的点对点MSE损失和提出的轨迹级MEE损失：<br>$\mathcal{L} = \mathcal{L}<em>{\mathrm{MSE}} + \lambda \mathcal{L}</em>{\mathrm{MEE}}$，<br>其中 $\lambda$ 是平衡两项的权重系数。</p>
<p><strong>核心模块：轨迹级最小误差熵（T-MEE）及其变体</strong></p>
<ol>
<li><p><strong>轨迹级MEE（T-MEE）</strong>：标准MEE应用于回归时通常针对独立同分布样本。本文将其适配到VLA的序列决策场景，在轨迹级别计算误差熵。对于一个包含 $T$ 个时间步的轨迹，定义轨迹误差向量 $\mathbf{e} = [e^1, e^2, ..., e^T] \in \mathbb{R}^{d \times T}$，其中 $e^t = a^t - \hat{a}^t$。使用二次Rényi熵的核密度估计近似，T-MEE损失定义为：<br>$\mathcal{L}<em>{\mathrm{T-MEE}} = -\log \left( \frac{1}{N^2} \sum</em>{i=1}^{N} \sum_{j=1}^{N} G_{\sqrt{2}\sigma}(\mathbf{e}_i - \mathbf{e}<em>j) \right)$，<br>其中 $N$ 是批次大小，$G</em>{\sigma}$ 是带宽为 $\sigma$ 的高斯核。该损失鼓励批次内所有轨迹的误差向量在 $\mathbb{R}^{d \times T}$ 空间中聚集，从而塑造一个更紧凑、结构化的误差分布。</p>
</li>
<li><p><strong>块加权T-MEE（Cw-T-MEE）</strong>：考虑到长轨迹中不同时间区间可能具有不同的重要性，此变体将轨迹划分为 $K$ 个连续块（chunk），为每个块分配一个可学习的权重 $w_k$。损失计算为各块MEE损失的加权和：<br>$\mathcal{L}<em>{\mathrm{Cw-T-MEE}} = \sum</em>{k=1}^{K} w_k \cdot \mathcal{L}_{\mathrm{MEE}}^{(k)}$，<br>权重通过softmax归一化。这允许模型自适应地关注对任务成功更关键的轨迹阶段。</p>
</li>
<li><p><strong>元素加权T-MEE（Ew-T-MEE）</strong>：为了在动作空间的不同维度（如位置、姿态、抓取）上实现更细粒度的控制，此变体为误差向量的每个元素（维度）分配一个权重。损失计算为：<br>$\mathcal{L}<em>{\mathrm{Ew-T-MEE}} = -\log \left( \frac{1}{N^2} \sum</em>{i=1}^{N} \sum_{j=1}^{N} G_{\sqrt{2}\sigma}(W \odot (\mathbf{e}_i - \mathbf{e}_j)) \right)$，<br>其中 $W$ 是一个可学习的权重向量，$\odot$ 表示逐元素乘法。这使得模型可以区分不同动作维度误差的重要性。</p>
</li>
</ol>
<p><img src="https://arxiv.org/html/2602.04228v1/x2.png" alt="方法框架"></p>
<blockquote>
<p><strong>图2</strong>：本工作评估的连续动作VLA模型架构分类。总结了代表性的大规模和小规模VLA架构。(a-b) 小规模模型使用轻量级骨干网络从多模态特征回归动作；(c-f) 大规模模型基于预训练的VLM构建。</p>
</blockquote>
<p><strong>创新点</strong>：与现有仅使用MSE等点对点回归损失的方法相比，本文的创新在于首次将信息论的MEE准则系统性地引入VLA训练。通过提出轨迹级别的T-MEE及其加权变体，方法能够在优化个体误差大小的同时，显式地规范误差分布的全局结构和集中度，实现了从“点”到“分布”的监督视角转变。</p>
<h2 id="实验与结果">实验与结果</h2>
<p><strong>实验设置</strong>：</p>
<ul>
<li><strong>数据集/基准</strong>：仿真环境使用 <strong>LIBERO</strong>（包含90个任务的套件，重点关注LIBERO-Object的10个任务）和 <strong>SimplerEnv</strong>（包含10个任务）。真实机器人实验在Franka Emika Panda机械臂上进行。</li>
<li><strong>评估的VLA架构</strong>：涵盖小规模和大规模模型，包括 <strong>BC-RNN</strong>, <strong>BC-Transformer</strong>, <strong>BC-DP</strong> (扩散策略), <strong>OFT</strong>, <strong>GR00T</strong>, <strong>$\pi_0$</strong> 系列变体, <strong>DS-VLA</strong> (双系统VLA)。</li>
<li><strong>对比基线</strong>：各架构下标准的基于MSE的行为克隆（BC）训练。</li>
<li><strong>实验场景</strong>：标准（近平衡）数据、少样本学习、带噪声数据、不平衡数据。</li>
</ul>
<p><strong>关键实验结果</strong>：</p>
<ol>
<li><strong>标准与少样本设置</strong>：在LIBERO-Object的10个任务上，T-MEE为所有测试的VLA架构带来了成功率的普遍提升。例如，BC-Transformer的整体成功率从57.4%提升至68.2%，GR00T从94.4%提升至97.8%。在少样本设置下（每任务仅10条演示），BC-Transformer的成功率从22.8%提升至31.0%，GR00T从68.6%提升至78.2%。</li>
</ol>
<p><img src="https://arxiv.org/html/2602.04228v1/x1.png" alt="定性结果1"></p>
<blockquote>
<p><strong>图1</strong>：使用和不使用轨迹级MEE（T-MEE）时动作误差分布的PCA可视化。每个点代表轨迹中特定时间步的动作误差。结果表明，引入T-MEE后，误差分布在投影空间中变得更加紧凑和连贯。</p>
</blockquote>
<ol start="2">
<li><p><strong>噪声鲁棒性</strong>：在向专家动作注入高斯噪声的设定下，使用T-MEE训练的模型表现出更强的鲁棒性。对于BC-Transformer，在噪声标准差为0.1时，成功率比基线高约10%。</p>
</li>
<li><p><strong>不平衡数据设置</strong>：通过系统改变任务间的样本比例来模拟数据不平衡。实验表明，本文提出的MEE目标在中等不平衡程度下能带来显著增益，但在极端不平衡（如某个任务样本占比超过90%）时，其增益会减弱或消失。论文据此刻画了该方法的有效操作区间。</p>
</li>
</ol>
<p><img src="https://arxiv.org/html/2602.04228v1/x4.png" alt="消融实验"></p>
<blockquote>
<p><strong>图4</strong>：在LIBERO-Object上，不同训练数据量（少样本）下，T-MEE及其变体相对于MSE基线的相对性能提升。所有MEE变体在数据稀缺时均能带来显著改进。</p>
</blockquote>
<ol start="4">
<li><strong>消融实验</strong>：<ul>
<li><strong>损失组件</strong>：单独使用T-MEE而不结合MSE会导致性能下降，表明点对点回归约束仍是必要的。MSE与T-MEE的组合效果最佳。</li>
<li><strong>加权变体比较</strong>：Cw-T-MEE和Ew-T-MEE在大多数情况下与T-MEE性能相当，在某些特定场景（如某些架构下的少样本学习）略有优势，提供了更灵活的控制。</li>
<li>**带宽参数 $\sigma$**：实验表明性能对 $\sigma$ 的选择在一定范围内不敏感，提供了一个鲁棒的操作区间。</li>
</ul>
</li>
</ol>
<p><img src="https://arxiv.org/html/2602.04228v1/x3.png" alt="结果对比"></p>
<blockquote>
<p><strong>图3</strong>：在LIBERO-Object基准上，不同VLA架构使用标准MSE训练与结合T-MEE训练的整体成功率对比。T-MEE为所有架构带来了性能提升。</p>
</blockquote>
<ol start="5">
<li><strong>真实机器人实验</strong>：在6个真实世界桌面操作任务上，使用BC-Transformer架构，结合T-MEE的训练将平均成功率从68.3%提升至81.7%，验证了方法的实际有效性。</li>
</ol>
<h2 id="总结与启发">总结与启发</h2>
<p><strong>核心贡献</strong>：</p>
<ol>
<li><strong>新视角与新目标</strong>：首次从分布视角审视VLA模型中的动作误差，并将最小误差熵（MEE）准则适配到该领域，提出了轨迹级MEE（T-MEE）及其加权变体（Cw-T-MEE, Ew-T-MEE），为连续动作VLA训练提供了超越点对点回归的新型监督信号。</li>
<li><strong>理论分析</strong>：从理论上分析了MEE目标的优化行为，揭示了其三个关键特性：诱导误差间的相似性加权相互作用、对异常误差的影响具有内在有界性、通过误差空间相互作用耦合或解耦多任务学习。这为方法的有效性提供了原理性解释。</li>
<li><strong>全面实证验证</strong>：在多个仿真基准和真实机器人任务上，跨不同架构和模型规模，在平衡、少样本、噪声和不平衡等多种数据机制下，系统验证了所提方法能一致地提升成功率和鲁棒性，且几乎不增加训练成本，不影响推理效率。</li>
</ol>
<p><strong>局限性</strong>：论文指出，在<strong>极端不平衡的数据机制下</strong>（例如某个任务占据绝大多数样本），MEE带来的性能增益会减弱。这是因为MEE依赖于误差样本间的相互作用，当某个任务的误差样本主导了批次时，其分布整形效应可能无法有效惠及其他任务。</p>
<p><strong>后续研究启示</strong>：</p>
<ol>
<li>本文的工作为VLA乃至更广泛的连续控制策略学习开辟了“分布感知”训练的新方向。未来可以探索其他信息论度量（如互信息）或更复杂的分布距离来塑造误差或表征的分布。</li>
<li>论文对MEE有效操作区间的刻画（中等不平衡下有效）为在实际不平衡数据集中应用此类方法提供了实用指南。如何扩展该方法在极端不平衡或长尾分布下的有效性是一个值得探索的问题。</li>
<li>将分布级监督与更高级别的策略约束（如任务子目标、技能语义）相结合，可能进一步释放VLA模型的泛化与推理潜力。</li>
</ol>

      </section>
      <section class="detail-tldr">
        <h2>💡 一句话总结</h2>
        <p>本文针对连续动作的视觉-语言-动作模型，指出传统均方误差损失函数对预测施加过强的逐点约束，限制了模型的鲁棒性。为此，作者引入信息论中的最小误差熵准则，提出轨迹级MEE目标及其两种加权变体，并与MSE结合用于训练。实验在LIBERO等仿真基准和真实机器人任务上进行，结果表明该方法在标准、少样本和噪声场景下均能持续提升成功率与鲁棒性，且训练成本增加可忽略，不影响推理效率。</p>
      </section>
      <div class="detail-actions">
        <a href="http://arxiv.org/abs/2602.04228" target="_blank" rel="noreferrer" class="btn">查看 arXiv 原文</a>
        <a href="../index.html" class="btn btn-outline">返回列表</a>
      </div>
    </article>
  </main>
  <footer class="site-footer">
    <span>数据抓取来源于 Robotics arXiv Daily</span>
    <span>本页由 GitHub Actions 定时更新</span>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}],throwOnError:false})"></script>
</body>
</html>