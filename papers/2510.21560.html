<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Learning Neural Control Barrier Functions from Expert Demonstrations using Inverse Constraint Learning - Robotics arXiv Daily</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="../assets/styles.css"/>
  <link rel="stylesheet" href="../assets/detail.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/>
</head>
<body>
  <div class="bg-orbit"></div>
  <header class="site-header">
    <div class="brand">
      <a href="../index.html" class="back-link">← 返回列表</a>
    </div>
  </header>
  <main class="detail-main">
    <article class="detail-card">
      <span class="detail-category">Manipulation</span>
      <h1>Learning Neural Control Barrier Functions from Expert Demonstrations using Inverse Constraint Learning</h1>
      <div class="detail-meta">
        <span>arXiv: <a href="http://arxiv.org/abs/2510.21560" target="_blank" rel="noreferrer">2510.21560</a></span>
        <span>作者: Hussein Sibai Team</span>
        <span>日期: 2025-10-24</span>
      </div>
      <section class="detail-body">
        <h2>📝 详细解读</h2>
        <h2 id="研究背景与动机">研究背景与动机</h2>
<p>在自主系统的安全控制领域，控制屏障函数（CBF）被广泛用于设计安全滤波器，以最小程度地调整标称控制输入，从而保证系统安全。基于优化的CBF合成方法（如Sum-of-Squares和Hamilton-Jacobi可达性分析）虽然能提供构造性正确保证，但面临维数灾难问题。作为替代，监督深度学习方法被提出用于训练神经CBF，其设计更简单、可扩展性更强，但代价是失去了正确性保证。这类方法需要已标注的安全/不安全状态数据集，而获得这些标注通常并不简单，因为与故障集不相交的受控前向不变集可能并不明显（例如，在具有输入约束的系统、具有难以数学描述的复杂观测故障集的系统，或专家在演示中隐式避免的未知故障状态等情况下）。</p>
<p>本文针对<strong>故障集（应避免的状态集合）不明确或难以形式化指定</strong>这一具体痛点（例如自动驾驶中的跟车太近问题），提出了一种新的视角：利用一组更容易生成的、完成任务并避开故障集的<strong>专家演示</strong>，通过逆向约束学习（ICL）来训练神经CBF。核心思路是：首先使用ICL从专家演示中推断出一个约束函数，该函数能将系统状态分类为安全（属于与未知故障集不相交的受控前向不变集）和不安全；然后利用该函数标注一组新的模拟轨迹，并以此训练神经CBF。</p>
<h2 id="方法详解">方法详解</h2>
<p>本文提出的方法（ICL-CBF）是一个迭代训练框架，旨在从专家演示和已知的参考控制器中学习神经CBF。</p>
<p><img src="https://arxiv.org/html/2510.21560v1/x1.png" alt="方法框架"></p>
<blockquote>
<p><strong>图1</strong>：ICL-CBF训练框架。实线箭头代表专家轨迹，虚线箭头代表使用由参考控制器π_ref和神经CBF B_θ构成的CBF-QP策略生成的轨迹。首先，使用π_ref采样轨迹数据，并用学习到的约束函数c_φ进行标注，以此训练B_θ；然后，使用B_θ作为安全滤波器模拟系统；接着，计算采样轨迹与对应专家轨迹的差异，并据此更新c_φ；最后，用新的c_φ标注新采样的轨迹重新训练B_θ，如此迭代直至收敛。</p>
</blockquote>
<p><strong>整体流程</strong>：给定参考控制器π_ref、专家演示和系统动力学，算法交替执行两个步骤：1）<strong>训练神经CBF B_θ</strong>：使用当前约束函数c_φ对由π_ref采样得到的状态轨迹𝒳_S^B进行标注（安全/不安全），并基于标注数据通过最小化损失函数ℒ_Bθ来训练B_θ。2）<strong>更新约束函数c_φ</strong>：使用当前B_θ与π_ref构成的CBF-QP策略π̂_E采样新轨迹，得到状态集𝒳_S^c；然后通过最小化损失函数ℒ_cφ来更新c_φ，使其能够区分专家状态𝒳_E和π̂_E采样的状态𝒳_S^c。此过程迭代进行（算法1）。</p>
<p><strong>核心模块与技术细节</strong>：</p>
<ol>
<li><strong>约束函数c_φ的训练</strong>：c_φ是一个神经网络，其输出用于分类状态。损失函数ℒ_cφ旨在使c_φ在专家状态上输出负值（接近-1），在由当前CBF-QP策略π̂_E采样的状态上输出正值（接近+1），如公式(9)所示。</li>
<li><strong>神经CBF B_θ的训练</strong>：B_θ也是一个神经网络。其训练损失ℒ_Bθ（公式10）包含三项：<ul>
<li><strong>安全项</strong>：鼓励安全状态x_safe的B_θ值大于阈值ϵ_safe。</li>
<li><strong>不安全项</strong>：鼓励不安全状态x_unsafe的B_θ值小于阈值-ϵ_unsafe。</li>
<li><strong>上升条件项</strong>：对于安全的状态-动作对(x_safe, u_safe)，鼓励其满足CBF条件（公式3），即沿动力学的导数加上α(B(x))大于阈值ϵ_ascent，以确保B_θ确实是一个有效的CBF。<br>其中σ(·)是ReLU函数，各项有权重w_safe, w_unsafe, w_ascent。</li>
</ul>
</li>
</ol>
<p><strong>创新点与现有方法对比</strong>：</p>
<ul>
<li>与Robey等人和ROCBF等方法需要显式在安全区域边界采样或使用反向KNN检测边界不同，本文利用ICL和已知参考控制器，推断专家因安全违规而避开的状态，并将其视为不安全，避免了低效的边界采样问题。</li>
<li>与iDBF使用行为克隆策略采样低概率动作来生成分布外（不安全）状态不同，本文直接利用参考控制器与学习到的约束来识别不安全区域。</li>
<li>核心创新在于将ICL框架与CBF训练相结合，通过迭代优化约束函数和CBF，从专家演示中直接学习安全滤波器，而无需预先指定故障集的数学形式。</li>
</ul>
<p><strong>训练启发式（针对低维动作空间）</strong>：为了加速训练，论文提出一种启发式方法：在前N-1次迭代中，不训练B_θ，而是使用网格搜索在动作空间中寻找不违反当前约束c_φ的控制输入来近似π̂_E；仅在最后一次迭代中，当c_φ已收敛并能提供更准确标签时，才训练最终的神经CBF B_θ。这使得在线部署时可以使用高效的CBF-QP策略。</p>
<h2 id="实验与结果">实验与结果</h2>
<p><strong>实验设置</strong>：在四个环境中评估方法：单积分器（2D避障）、Dubins车（避障）、倒立摆（保持安全区域）、四旋翼（避撞地面）。使用多层感知机表示约束函数和神经CBF。</p>
<p><strong>对比基线</strong>：</p>
<ul>
<li>GT：使用真实CBF（用于生成专家演示）的安全滤波器。</li>
<li>L-CBF：使用由π_ref采样、并由真实CBF标注的轨迹训练的神经CBF（提供了使用完美标签的上限）。</li>
<li>ROCBF：基于边界检测的神经CBF方法。</li>
<li>iDBF：基于分布外检测的神经CBF方法。</li>
</ul>
<p><strong>关键实验结果</strong>：<br><img src="https://arxiv.org/html/2510.21560v1/x2.png" alt="结果对比1"></p>
<blockquote>
<p><strong>图2</strong>：单积分器场景下，不同方法在100次测试运行中的成功率和安全违规次数。ICL-CBF和ICL-CBF (heuristic)均实现了100%成功率且零违规，与L-CBF和GT性能相当，优于ROCBF和iDBF。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x3.png" alt="结果对比2"></p>
<blockquote>
<p><strong>图3</strong>：倒立摆场景的结果。ICL-CBF方法成功率最高（98%），安全违规次数（2次）与L-CBF（1次）和GT（0次）接近，且远低于ROCBF和iDBF。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x4.png" alt="结果对比3"></p>
<blockquote>
<p><strong>图4</strong>：Dubins车场景的结果。ICL-CBF方法成功率（87%）和违规次数（13次）与L-CBF（89%， 11次）最为接近，优于其他基线。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x5.png" alt="结果对比4"></p>
<blockquote>
<p><strong>图5</strong>：四旋翼场景的结果。所有学习到CBF的方法（包括ICL-CBF）都出现了一些安全违规，但ICL-CBF的成功率（66%）与L-CBF（67%）几乎相同，且优于ROCBF和iDBF。</p>
</blockquote>
<p><strong>消融实验与深入分析</strong>：<br><img src="https://arxiv.org/html/2510.21560v1/x6.png" alt="消融实验1"></p>
<blockquote>
<p><strong>图6</strong>（对应RQ2）：在单积分器上，比较完整算法与启发式算法（网格搜索π̂_E并仅在最后训练B_θ）。两者性能无显著差异，表明启发式有效且未降低质量。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x7.png" alt="消融实验2"></p>
<blockquote>
<p><strong>图7</strong>（对应RQ3）：比较使用π_ref（原始算法）与使用π̂_E（变体）来生成训练B_θ的轨迹𝒳_S^B。使用π_ref采样训练出的CBF性能更好，因为它覆盖了更广的状态空间，包括参考控制器可能导向的不安全区域。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x8.png" alt="精度分析"></p>
<blockquote>
<p><strong>图8</strong>（对应RQ4）：在单积分器和倒立摆场景中，学习到的约束函数c_φ对状态的分类准确率。随着训练进行，准确率迅速上升并稳定在高位（&gt;95%），表明ICL能产生准确的伪安全标签。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x9.png" alt="超参数敏感性"></p>
<blockquote>
<p><strong>图9</strong>（对应RQ5）：分析超参数δ（用于根据c_φ值划分安全/不安全状态的阈值）的影响。在单积分器上，δ在0.2到0.8之间时性能稳定；在倒立摆上，δ=0.3时性能最佳，偏离此值会导致性能下降。</p>
</blockquote>
<p><strong>定性结果</strong>：<br><img src="https://arxiv.org/html/2510.21560v1/x10.png" alt="定性结果1"></p>
<blockquote>
<p><strong>图10</strong>：单积分器场景的轨迹可视化。ICL-CBF引导智能体成功绕开障碍物到达目标，其轨迹与GT和L-CBF的轨迹相似。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/x11.png" alt="定性结果2"></p>
<blockquote>
<p><strong>图11</strong>：学习到的神经CBF B_θ的0-水平集（安全边界）可视化。在单积分器和倒立摆场景中，ICL-CBF学习到的安全集（红色曲线内区域）与真实安全集（蓝色阴影）非常吻合。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2510.21560v1/figs/data_pen_icl.png" alt="数据分布对比"></p>
<blockquote>
<p><strong>图12-15</strong>：展示了在倒立摆场景中，不同方法（ICL-CBF, iDBF, ROCBF）用于训练CBF的数据点分布，以及与真实安全集（GT）的对比。ICL-CBF的采样点（特别是用于训练的不安全点）更集中地分布在真实安全边界附近，而iDBF和ROCBF的采样点分布则相对分散或偏离。</p>
</blockquote>
<h2 id="总结与启发">总结与启发</h2>
<p><strong>核心贡献</strong>：</p>
<ol>
<li>提出了ICL-CBF框架，首次将逆向约束学习与神经控制屏障函数训练相结合，能够仅从专家演示和已知参考控制器中学习安全滤波器，而无需形式化指定故障集。</li>
<li>通过理论联系（理想ICL约束对应未知故障集的后向可达集）和大量实验证明，该方法在多个连续控制环境中能学习到有效的CBF，其性能与使用真实安全标签训练的方法相当，并优于现有基线。</li>
<li>提出了一种适用于低维动作空间的训练启发式，能加速训练而不降低最终性能。</li>
</ol>
<p><strong>局限性</strong>：</p>
<ol>
<li>论文提到的启发式方法（网格搜索）仅适用于低维动作空间，对于高维动作空间，原始迭代算法可能更有效。</li>
<li>方法假设专家演示充分覆盖了状态空间（除了真实的约束集）。如果专家在安全集内也偏离参考控制器，学习到的约束集可能会是真实约束集的保守估计。</li>
<li>实验表明，在复杂的四旋翼环境中，所有数据驱动的神经CBF方法都未能完全避免安全违规，表明在高维非线性系统中保证安全仍然是一个挑战。</li>
</ol>
<p><strong>对后续研究的启示</strong>：</p>
<ol>
<li>为在故障集难以形式化的复杂场景中获取安全规范提供了一条数据驱动的可行路径。</li>
<li>将ICL与CBF结合的框架可以扩展至多任务设置（算法1备注），以学习跨任务共享的约束。</li>
<li>未来工作可以探索如何将学习到的神经CBF与形式化验证方法结合，以提供更强的安全保证，或研究如何降低对专家演示覆盖范围的要求。</li>
</ol>

      </section>
      <section class="detail-tldr">
        <h2>💡 一句话总结</h2>
        <p>本文研究在失败状态集不明确时，如何从专家示范中学习神经控制障碍函数以确保自主系统安全。提出采用逆向约束学习方法，从专家轨迹中推断出能将系统状态分类为安全与不安全的约束函数，并利用该函数标注模拟轨迹数据来训练神经CBF。在四个不同环境中的实验表明，该方法优于现有基线，且性能与使用真实安全标签训练的神经CBF相当。</p>
      </section>
      <div class="detail-actions">
        <a href="http://arxiv.org/abs/2510.21560" target="_blank" rel="noreferrer" class="btn">查看 arXiv 原文</a>
        <a href="../index.html" class="btn btn-outline">返回列表</a>
      </div>
    </article>
  </main>
  <footer class="site-footer">
    <span>数据抓取来源于 Robotics arXiv Daily</span>
    <span>本页由 GitHub Actions 定时更新</span>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}],throwOnError:false})"></script>
</body>
</html>