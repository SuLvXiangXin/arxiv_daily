<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Unified Multimodal Diffusion Forcing for Forceful Manipulation - Robotics arXiv Daily</title>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet"/>
  <link rel="stylesheet" href="../assets/styles.css"/>
  <link rel="stylesheet" href="../assets/detail.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"/>
</head>
<body>
  <div class="bg-orbit"></div>
  <header class="site-header">
    <div class="brand">
      <a href="../index.html" class="back-link">← 返回列表</a>
    </div>
  </header>
  <main class="detail-main">
    <article class="detail-card">
      <span class="detail-category">Manipulation</span>
      <h1>Unified Multimodal Diffusion Forcing for Forceful Manipulation</h1>
      <div class="detail-meta">
        <span>arXiv: <a href="http://arxiv.org/abs/2511.04812" target="_blank" rel="noreferrer">2511.04812</a></span>
        <span>作者: Dmitry Berenson Team</span>
        <span>日期: 2025-11-06</span>
      </div>
      <section class="detail-body">
        <h2>📝 详细解读</h2>
        <h2 id="研究背景与动机">研究背景与动机</h2>
<p>当前机器人模仿学习的主流方法通常学习从观测（如RGB图像）到动作的直接映射。这些方法往往忽略了不同模态（如感知输入、动作和奖励）之间丰富的相互作用，而这种相互作用对于建模机器人行为和理解任务结果至关重要。此外，现有方法通常假设固定的输入模态集，在推理时缺乏对部分可观测性或数据损坏的鲁棒性。</p>
<p>本文针对上述痛点，提出了一个统一的多模态机器人轨迹学习框架，超越了单纯的动作生成。核心思路是：通过引入一个二维的“时间-模态”噪声水平矩阵，对多模态轨迹进行随机部分掩码，并训练一个扩散模型来重建轨迹。这种训练目标促使模型学习时间和跨模态的依赖关系。</p>
<h2 id="方法详解">方法详解</h2>
<p>本文提出的统一多模态扩散强制（Multimodal Diffusion Forcing， MDF）框架旨在学习多模态机器人轨迹的联合分布。其核心创新在于将标准扩散模型（使用单一全局噪声水平）扩展为使用一个二维的“时间-模态”噪声水平矩阵进行训练。</p>
<p><img src="https://arxiv.org/html/2511.04812v1/x1.png" alt="方法框架与推理配置"></p>
<blockquote>
<p><strong>图1</strong>：MDF方法概览与推理灵活性。左：标准扩散模型使用标量噪声水平，Diffusion Forcing使用随时间变化的噪声向量，而MDF进一步推广到二维的“时间-模态”噪声矩阵。右：通过配置噪声矩阵（条件块、目标块、丢弃块），单一MDF模型可在推理时灵活实现策略、规划器、动力学模型和细粒度异常检测器等多种功能。</p>
</blockquote>
<p>整体框架采用双层结构，包括预训练的点云扩散自编码器和用于序列建模的潜在扩散Transformer。输入是一个多模态轨迹τ，每个时间步包含多种模态的特征（如点云、力、动作、奖励等）。训练时，随机采样一个噪声矩阵K，其中每个元素k_{t,m}指定了在时间t对模态m施加的噪声水平（扩散步数）。随后对轨迹进行前向扩散加噪，得到噪声化轨迹τ^K。模型ϵ_θ以τ^K和矩阵K为输入，被训练去预测添加到每个模态-时间步上的噪声。损失函数为标准DDPM目标在时间和模态维度上的求和。</p>
<p><img src="https://arxiv.org/html/2511.04812v1/x2.png" alt="训练流程"></p>
<blockquote>
<p><strong>图2</strong>：MDF训练流程。首先预训练点云自编码器以获得紧凑的点云嵌入。在MDF训练中，处理六种模态的数据（部分点云、完整点云、力、动作、奖励和本体感知），通过预训练编码器进行标记化，然后根据随机采样的2D噪声矩阵进行加噪。一个扩散Transformer被训练去噪此加噪输入，从而学习时空和跨模态依赖。</p>
</blockquote>
<p>具体技术细节包括：</p>
<ol>
<li><strong>点云自编码器</strong>：由于点云的高维和无序性，采用基于扩散的点云自编码器（包含轻量级PointNet编码器和扩散解码器）将点云压缩为低维潜在嵌入。</li>
<li><strong>潜在扩散Transformer</strong>：将每个时间步各模态的编码特征与对应的噪声水平嵌入拼接，形成融合的多模态特征向量序列。该序列被送入一个Transformer，在潜在空间内进行去噪和序列建模。</li>
<li><strong>灵活的推理机制</strong>：推理时，通过配置噪声矩阵K来定义条件分布。将矩阵划分为三类块：<strong>条件块</strong>（噪声水平接近0，信息保留）、<strong>目标块</strong>（初始化为高斯噪声并逐步去噪至0）和<strong>丢弃块</strong>（保持最大噪声水平）。通过这种配置，同一模型可实现多种功能，例如：作为<strong>策略</strong>（以过去观测为条件预测未来动作）、作为<strong>规划器</strong>（额外预测未来状态和观测）、作为<strong>逆动力学模型</strong>（从观测预测动作），或适应不同的历史长度和可用传感器模态。</li>
<li><strong>细粒度异常定位</strong>：基于扩散模型的似然估计能力，提出了一种模态-时间扫描算法。该算法不是扰动整个轨迹，而是选择性地将噪声注入单个（时间，模态）条目，通过计算KL散度来度量该局部扰动与模型预期行为的偏差，从而精确定位异常发生的时间和模态。</li>
</ol>
<p>与现有方法相比，MDF的创新点主要体现在：1) 将“噪声即掩码”的思想推广到多模态和时间的二维连续掩码，而非二进制掩码；2) 统一的训练框架能够同时学习多种概率分布（策略、动力学等）；3) 在推理时提供了前所未有的灵活性，可通过单一模型实现多种下游任务。</p>
<h2 id="实验与结果">实验与结果</h2>
<p>实验在模拟和真实世界环境中进行。模拟任务包括三个来自Nvidia Factory的接触式操作任务：螺母拧入、齿轮啮合和销插入。真实世界任务包括两个力控操作任务：使用KUKA iiwa进行螺母拧入和使用Franka Panda进行销插入。基线方法包括：统一世界模型（UWM）、3D扩散策略（DP3），以及MDF的几种变体（策略模式、规划器模式、无力信号、无状态估计）。</p>
<p><img src="https://arxiv.org/html/2511.04812v1/figs/tasks.png" alt="模拟任务"></p>
<blockquote>
<p><strong>图3</strong>：在IsaacSim中评估的三个接触式操作任务：螺母拧入、齿轮啮合和销插入。</p>
</blockquote>
<p>关键定量结果总结如下表：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">螺母拧入</th>
<th align="left">齿轮啮合</th>
<th align="left">销插入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DP3</td>
<td align="left">96%</td>
<td align="left">80%</td>
<td align="left">84%</td>
</tr>
<tr>
<td align="left">UWM</td>
<td align="left">96%</td>
<td align="left">54%</td>
<td align="left">58%</td>
</tr>
<tr>
<td align="left"><strong>MDF-Policy</strong></td>
<td align="left"><strong>100%</strong></td>
<td align="left"><strong>86%</strong></td>
<td align="left"><strong>80%</strong></td>
</tr>
<tr>
<td align="left">MDF-Planner</td>
<td align="left">92%</td>
<td align="left">84%</td>
<td align="left">78%</td>
</tr>
<tr>
<td align="left">MDF-Policy-Noisy PC</td>
<td align="left">94%</td>
<td align="left">84%</td>
<td align="left">86%</td>
</tr>
<tr>
<td align="left">DP3-Noisy PC</td>
<td align="left">78%</td>
<td align="left">68%</td>
<td align="left">76%</td>
</tr>
<tr>
<td align="left">MDF-policy-No wrench</td>
<td align="left">72%</td>
<td align="left">78%</td>
<td align="left">74%</td>
</tr>
<tr>
<td align="left">MDF-Policy-No state estimation</td>
<td align="left">74%</td>
<td align="left">74%</td>
<td align="left">70%</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>表1</strong>：各方法在50个随机配置下的成功率对比。MDF-Policy在多数任务上达到或超越了专用策略DP3的性能，并显著优于另一统一模型UWM。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2511.04812v1/x3.png" alt="历史长度适应性"></p>
<blockquote>
<p><strong>图4</strong>：MDF在推理时可动态调整历史长度以适应任务需求。例如，在齿轮啮合任务中，使用更长的历史（8步）可获得比标准4步历史（86%）更高的成功率（92%）。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2511.04812v1/x4.png" alt="真实世界任务1"></p>
<blockquote>
<p><strong>图5</strong>：真实世界任务1：使用KUKA iiwa进行螺母拧入。MDF成功完成了任务。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2511.04812v1/x5.png" alt="真实世界任务2"></p>
<blockquote>
<p><strong>图6</strong>：真实世界任务2：使用Franka Panda进行销插入。MDF成功完成了任务。</p>
</blockquote>
<p><img src="https://arxiv.org/html/2511.04812v1/x6.png" alt="异常检测"></p>
<blockquote>
<p><strong>图7</strong>：细粒度异常检测的定性结果。MDF能够精确定位异常发生的时间和具体模态（如“力”模态在特定时间步出现异常）。</p>
</blockquote>
<p>实验结果分析：</p>
<ol>
<li><strong>性能</strong>：尽管MDF是统一模型，但其策略模式（MDF-Policy）在性能上与传统专用架构（DP3）相当甚至更优（如螺母拧入任务100% vs 96%），并显著优于另一统一模型UWM。这表明统一训练并未牺牲性能。</li>
<li><strong>鲁棒性</strong>：当向点云输入注入随机平移噪声以模拟相机标定误差时，MDF性能下降很小（螺母拧入从100%降至94%），而DP3下降更显著（从96%降至78%），证明了MDF连续掩码训练对噪声的鲁棒性。</li>
<li><strong>灵活性</strong>：MDF支持在测试时动态调整历史长度（图4），并能适应不同的传感器配置（例如，在没有力传感器时，可将力模态设为丢弃或预测目标）。</li>
<li><strong>消融实验</strong>：移除力信号（MDF-No Wrench）或禁止模型预测完整点云状态（MDF-Policy-No State Estimation）均会导致性能显著下降，证明了力推理和状态估计对于接触式任务的重要性。规划器模式（MDF-Planner）在测试的短视距任务中略逊于直接策略模式，作者推测对于需要复杂推理的长视距任务，规划可能更有优势。</li>
<li><strong>额外能力</strong>：MDF成功应用于真实世界力控操作（图5，图6），并展示了其细粒度异常检测与定位的能力（图7）。</li>
</ol>
<h2 id="总结与启发">总结与启发</h2>
<p>本文的核心贡献可概括为三点：</p>
<ol>
<li><strong>提出了统一的多模态扩散强制（MDF）框架</strong>：通过引入二维时间-模态噪声矩阵，实现了对多模态机器人轨迹联合分布的统一学习，能够捕获复杂的跨模态和时间依赖。</li>
<li><strong>实现了前所未有的推理时灵活性</strong>：单一MDF模型可通过配置噪声矩阵，零样本适应多种下游任务，如动作生成、规划、动力学建模、状态估计和细粒度异常检测，并能动态调整历史长度和输入模态。</li>
<li><strong>增强了模型的鲁棒性</strong>：基于连续噪声水平的训练使模型对部分观测和传感器噪声更具鲁棒性。</li>
</ol>
<p>论文提到的局限性包括：方法涉及点云自编码器的预训练和潜在扩散模型的训练，计算成本可能较高；尽管在实验中表现出色，但在更复杂的多任务、长视距场景中的有效性仍需进一步验证。</p>
<p>本工作对后续研究的启示在于：它展示了通过统一的、基于掩码（噪声）的训练框架来学习多模态序列的潜力，这种框架能够自然地将多种机器人学习任务（策略、模型、估计）整合到一个模型中，并赋予其强大的泛化、适应和诊断能力。这一思路可推广至包含更丰富模态（如语言、音频）的序列建模中。</p>

      </section>
      <section class="detail-tldr">
        <h2>💡 一句话总结</h2>
        <p>本文针对接触丰富的机器人强力操作任务，提出**多模态扩散强制（MDF）**框架，以解决传统模仿学习方法忽视多模态（如图像、力信号）间时序依赖与跨模态关联的问题。其核心方法采用**2D时间-模态噪声水平矩阵**进行训练，通过**随机部分掩码**策略，迫使扩散模型学习重建轨迹，从而捕获模态间交互与时间动态。实验在模拟与真实环境中的五个强力操作任务上进行，结果表明，MDF在实现多功能性的同时，展现出**强大的性能**，并在**噪声观测下具有优异鲁棒性**。</p>
      </section>
      <div class="detail-actions">
        <a href="http://arxiv.org/abs/2511.04812" target="_blank" rel="noreferrer" class="btn">查看 arXiv 原文</a>
        <a href="../index.html" class="btn btn-outline">返回列表</a>
      </div>
    </article>
  </main>
  <footer class="site-footer">
    <span>数据抓取来源于 Robotics arXiv Daily</span>
    <span>本页由 GitHub Actions 定时更新</span>
  </footer>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}],throwOnError:false})"></script>
</body>
</html>